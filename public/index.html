<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PIXEL WAR 3D - NPC Update</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; }
        canvas { width: 100vw; height: 100vh; image-rendering: pixelated; }
        
        #ui { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none; z-index: 5; font-weight: bold;}
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; 
            background: #0f0; transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 5px #0f0;
        }

        /* 登入介面 */
        #login { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 10; }
        .box { text-align: center; color: white; background: #222; padding: 40px; border: 4px solid #444; }
        input { padding: 10px; font-size: 1.5rem; background: #111; color: #0f0; border: 1px solid #444; width: 250px; text-align: center; }
        button { margin-top: 20px; padding: 10px 40px; font-size: 1.5rem; cursor: pointer; background: #d32f2f; color: white; border: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="login">
        <div class="box">
            <h1 style="color:#d32f2f; font-size: 3rem; margin: 0 0 20px 0;">PIXEL WAR 3D</h1>
            <input type="text" id="username" placeholder="CODENAME" maxlength="12">
            <br>
            <button onclick="joinGame()">DEPLOY</button>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="ui">
        HP <span id="hp" style="color: #0f0;">100</span> | 
        KILLS <span id="kills" style="color: yellow;">0</span>
    </div>
    
    <canvas id="screen" width="320" height="200"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d', { alpha: false });

        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 200;
        const BLOCK_SIZE = 64;
        const FOV = 0.66;
        
        let map = [];
        let myId = null;
        let players = {};
        let bullets = [];
        
        let px = 150, py = 150;
        let dirX = -1, dirY = 0;
        let planeX = 0, planeY = 0.66;
        
        const keys = { w: false, a: false, s: false, d: false };
        let shootCooldown = 0;
        let walkWobble = 0; // 走路搖晃參數

        function joinGame() {
            const name = document.getElementById('username').value.trim() || "Marine";
            document.getElementById('login').style.display = 'none';
            socket.emit('join', { username: name });
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.onclick = () => canvas.requestPointerLock();
            canvas.requestPointerLock();
        }

        socket.on('init', (data) => { map = data.map; myId = data.id; });
        socket.on('state', (data) => {
            players = data.players;
            bullets = data.bullets;
            if (players[myId]) {
                const me = players[myId];
                if (Math.hypot(me.x - px, me.y - py) > 50) { px = me.x; py = me.y; }
                document.getElementById('hp').innerText = Math.max(0, me.hp);
                document.getElementById('kills').innerText = me.kills;
                
                // 受傷紅屏效果
                if (me.hp < 30) document.body.style.boxShadow = "inset 0 0 100px red";
                else document.body.style.boxShadow = "none";
            }
        });

        // ============================
        // 繪圖引擎
        // ============================
        function drawScene() {
            // 地板與天空
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
            ctx.fillStyle = '#222'; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

            if (map.length === 0) return;
            const zBuffer = new Array(SCREEN_WIDTH).fill(0);

            // 1. Raycasting (牆壁)
            for (let x = 0; x < SCREEN_WIDTH; x++) {
                const cameraX = 2 * x / SCREEN_WIDTH - 1;
                const rayDirX = dirX + planeX * cameraX;
                const rayDirY = dirY + planeY * cameraX;
                let mapX = Math.floor(px / BLOCK_SIZE);
                let mapY = Math.floor(py / BLOCK_SIZE);
                let sideDistX, sideDistY;
                const deltaDistX = Math.abs(1 / rayDirX);
                const deltaDistY = Math.abs(1 / rayDirY);
                let perpWallDist, stepX, stepY, hit = 0, side;

                if (rayDirX < 0) { stepX = -1; sideDistX = (px/BLOCK_SIZE - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - px/BLOCK_SIZE) * deltaDistX; }
                if (rayDirY < 0) { stepY = -1; sideDistY = (py/BLOCK_SIZE - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - py/BLOCK_SIZE) * deltaDistY; }

                while (hit === 0) {
                    if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                    if (map[mapY] && map[mapY][mapX] > 0) hit = 1;
                }

                if (side === 0) perpWallDist = (sideDistX - deltaDistX);
                else perpWallDist = (sideDistY - deltaDistY);
                zBuffer[x] = perpWallDist;

                const lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
                let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
                if (drawStart < 0) drawStart = 0;
                let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
                if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

                let color = 255 - perpWallDist * 15;
                if (side === 1) color *= 0.7; 
                ctx.fillStyle = `rgb(${color}, ${color/2}, ${color/2})`; // 紅磚牆
                ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
            }

            // 2. Sprites (敵人/Bot)
            const sprites = [];
            for (let id in players) {
                if (id === myId || players[id].hp <= 0) continue;
                sprites.push({ x: players[id].x, y: players[id].y, hp: players[id].hp, isBot: players[id].isBot });
            }
            // Bot 和 Player 用不同顏色
            sprites.sort((a, b) => ((px - b.x)**2 + (py - b.y)**2) - ((px - a.x)**2 + (py - a.y)**2));

            sprites.forEach(sprite => {
                const spriteX = (sprite.x - px) / BLOCK_SIZE;
                const spriteY = (sprite.y - py) / BLOCK_SIZE;
                const invDet = 1.0 / (planeX * dirY - dirX * planeY);
                const transformX = invDet * (dirY * spriteX - dirX * spriteY);
                const transformY = invDet * (-planeY * spriteX + planeX * spriteY);

                if (transformY > 0) {
                    const spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                    const spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                    const spriteWidth = spriteHeight / 2;
                    const spriteTop = (SCREEN_HEIGHT - spriteHeight) / 2;
                    const spriteLeft = spriteScreenX - spriteWidth / 2;

                    if (transformY < zBuffer[spriteScreenX]) {
                        // 繪製敵人身體
                        ctx.fillStyle = sprite.isBot ? '#d32f2f' : '#2196f3'; // Bot=紅, Player=藍
                        ctx.fillRect(spriteLeft, spriteTop, spriteWidth, spriteHeight);
                        // 眼睛 (判斷方向略難，先畫死)
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(spriteLeft + spriteWidth*0.2, spriteTop + spriteHeight*0.2, spriteWidth*0.2, spriteHeight*0.1);
                        ctx.fillRect(spriteLeft + spriteWidth*0.6, spriteTop + spriteHeight*0.2, spriteWidth*0.2, spriteHeight*0.1);
                    }
                }
            });

            // 3. 畫槍 (3D 透視感)
            drawGun3D();
        }

        function drawGun3D() {
            // 計算晃動 (Bobbing)
            let isMoving = keys.w || keys.s || keys.a || keys.d;
            if (isMoving) walkWobble += 0.15;
            else walkWobble = 0;

            // Figure-8 晃動軌跡
            const bobX = Math.cos(walkWobble) * 6; 
            const bobY = Math.abs(Math.sin(walkWobble)) * 6;

            // 後座力
            let recoil = 0;
            if (shootCooldown > 0) {
                recoil = 20; // 槍往後縮
                shootCooldown--;
            }

            // 槍的位置 (右下角延伸到中間)
            // 我們把槍托放在右下，槍管指向準心
            const centerX = SCREEN_WIDTH / 2;
            const gunBaseX = SCREEN_WIDTH * 0.7 + bobX; // 槍托位置 (偏右)
            const gunBaseY = SCREEN_HEIGHT + bobY + recoil; // 槍托底部

            ctx.save();
            
            // 1. 槍身 (Body) - 梯形透視
            // 從底部寬，延伸到中間窄
            ctx.fillStyle = '#3e2723'; // 深木頭色
            ctx.beginPath();
            ctx.moveTo(gunBaseX - 60, gunBaseY); // 底部左
            ctx.lineTo(gunBaseX + 60, gunBaseY); // 底部右
            ctx.lineTo(centerX + 10, SCREEN_HEIGHT / 2 + 60); // 頂部右 (靠近準心)
            ctx.lineTo(centerX - 10, SCREEN_HEIGHT / 2 + 60); // 頂部左
            ctx.fill();

            // 2. 槍管/金屬部分 (Metal Top)
            ctx.fillStyle = '#212121'; // 黑鐵色
            ctx.beginPath();
            ctx.moveTo(gunBaseX - 30, gunBaseY - 20); 
            ctx.lineTo(gunBaseX + 30, gunBaseY - 20);
            ctx.lineTo(centerX + 5, SCREEN_HEIGHT / 2 + 60);
            ctx.lineTo(centerX - 5, SCREEN_HEIGHT / 2 + 60);
            ctx.fill();

            // 3. 彈匣 (Magazine) - 在槍身左側畫一個斜塊
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.moveTo(gunBaseX - 30, gunBaseY - 50);
            ctx.lineTo(gunBaseX - 60, gunBaseY - 20);
            ctx.lineTo(gunBaseX - 50, gunBaseY - 100);
            ctx.fill();

            // 4. 槍口火焰 (Muzzle Flash)
            if (shootCooldown > 2) {
                ctx.fillStyle = `rgba(255, 235, 59, ${Math.random()})`;
                ctx.beginPath();
                // 火焰在準心下方一點點
                ctx.arc(centerX, SCREEN_HEIGHT / 2 + 50, 10 + Math.random() * 20, 0, Math.PI * 2);
                ctx.fill();
                
                // 核心白光
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(centerX, SCREEN_HEIGHT / 2 + 50, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // 輸入邏輯
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousedown', () => {
            if (document.pointerLockElement === canvas) {
                socket.emit('shoot');
                shootCooldown = 6;
            }
        });
        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                const sensitivity = 0.003;
                const rot = -e.movementX * sensitivity;
                const oldDirX = dirX;
                dirX = dirX * Math.cos(rot) - dirY * Math.sin(rot);
                dirY = oldDirX * Math.sin(rot) + dirY * Math.cos(rot);
                const oldPlaneX = planeX;
                planeX = planeX * Math.cos(rot) - planeY * Math.sin(rot);
                planeY = oldPlaneX * Math.sin(rot) + planeY * Math.cos(rot);
            }
        });

        function loop() {
            if (myId) {
                const moveSpeed = 0.1; 
                let dx = 0, dy = 0;
                // 客戶端簡單移動 (不傳給 server，只更新本地顯示，實際以 server 判定為主)
                if (keys.w) { px += dirX * moveSpeed; py += dirY * moveSpeed; } // 這裡只是示意，實際移動需傳給 server
                socket.emit('input', { keys, angle: Math.atan2(dirY, dirX) });
            }
            drawScene();
            requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

    </script>
</body>
</html>
