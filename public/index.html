<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PIXEL WAR 3D - NPC Update</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; user-select: none; }
        canvas { width: 100vw; height: 100vh; image-rendering: pixelated; }
        
        #ui { position: absolute; bottom: 20px; left: 20px; color: #0f0; font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none; z-index: 5; font-weight: bold;}
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; 
            background: #0f0; transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 5px #0f0;
        }

        /* 登入介面 */
        #login { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 10; }
        .box { text-align: center; color: white; background: #222; padding: 40px; border: 4px solid #444; }
        input { padding: 10px; font-size: 1.5rem; background: #111; color: #0f0; border: 1px solid #444; width: 250px; text-align: center; }
        button { margin-top: 20px; padding: 10px 40px; font-size: 1.5rem; cursor: pointer; background: #d32f2f; color: white; border: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="login">
        <div class="box">
            <h1 style="color:#d32f2f; font-size: 3rem; margin: 0 0 20px 0;">PIXEL WAR 3D</h1>
            <input type="text" id="username" placeholder="CODENAME" maxlength="12">
            <br>
            <button onclick="joinGame()">DEPLOY</button>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="ui">
        HP <span id="hp" style="color: #0f0;">100</span> | 
        KILLS <span id="kills" style="color: yellow;">0</span>
    </div>
    
    <canvas id="screen" width="320" height="200"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d', { alpha: false });

        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 200;
        const BLOCK_SIZE = 64;
        const FOV = 0.66;
        
        let map = [];
        let myId = null;
        let players = {};
        let bullets = [];
        
        let px = 150, py = 150;
        let dirX = -1, dirY = 0;
        let planeX = 0, planeY = 0.66;
        
        const keys = { w: false, a: false, s: false, d: false };
        let shootCooldown = 0;
        let walkWobble = 0; // 走路搖晃參數

        function joinGame() {
            const name = document.getElementById('username').value.trim() || "Marine";
            document.getElementById('login').style.display = 'none';
            socket.emit('join', { username: name });
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.onclick = () => canvas.requestPointerLock();
            canvas.requestPointerLock();
        }

        socket.on('init', (data) => { map = data.map; myId = data.id; });
        socket.on('state', (data) => {
            players = data.players;
            bullets = data.bullets;
            if (players[myId]) {
                const me = players[myId];
                if (Math.hypot(me.x - px, me.y - py) > 50) { px = me.x; py = me.y; }
                document.getElementById('hp').innerText = Math.max(0, me.hp);
                document.getElementById('kills').innerText = me.kills;
                
                // 受傷紅屏效果
                if (me.hp < 30) document.body.style.boxShadow = "inset 0 0 100px red";
                else document.body.style.boxShadow = "none";
            }
        });

        // ============================
        // 繪圖引擎
        // ============================
        function drawScene() {
            // 地板與天空
            ctx.fillStyle = '#111'; ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
            ctx.fillStyle = '#222'; ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

            if (map.length === 0) return;
            const zBuffer = new Array(SCREEN_WIDTH).fill(0);

            // 1. Raycasting (牆壁)
            for (let x = 0; x < SCREEN_WIDTH; x++) {
                const cameraX = 2 * x / SCREEN_WIDTH - 1;
                const rayDirX = dirX + planeX * cameraX;
                const rayDirY = dirY + planeY * cameraX;
                let mapX = Math.floor(px / BLOCK_SIZE);
                let mapY = Math.floor(py / BLOCK_SIZE);
                let sideDistX, sideDistY;
                const deltaDistX = Math.abs(1 / rayDirX);
                const deltaDistY = Math.abs(1 / rayDirY);
                let perpWallDist, stepX, stepY, hit = 0, side;

                if (rayDirX < 0) { stepX = -1; sideDistX = (px/BLOCK_SIZE - mapX) * deltaDistX; }
                else { stepX = 1; sideDistX = (mapX + 1.0 - px/BLOCK_SIZE) * deltaDistX; }
                if (rayDirY < 0) { stepY = -1; sideDistY = (py/BLOCK_SIZE - mapY) * deltaDistY; }
                else { stepY = 1; sideDistY = (mapY + 1.0 - py/BLOCK_SIZE) * deltaDistY; }

                while (hit === 0) {
                    if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
                    else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
                    if (map[mapY] && map[mapY][mapX] > 0) hit = 1;
                }

                if (side === 0) perpWallDist = (sideDistX - deltaDistX);
                else perpWallDist = (sideDistY - deltaDistY);
                zBuffer[x] = perpWallDist;

                const lineHeight = Math.floor(SCREEN_HEIGHT / perpWallDist);
                let drawStart = -lineHeight / 2 + SCREEN_HEIGHT / 2;
                if (drawStart < 0) drawStart = 0;
                let drawEnd = lineHeight / 2 + SCREEN_HEIGHT / 2;
                if (drawEnd >= SCREEN_HEIGHT) drawEnd = SCREEN_HEIGHT - 1;

                let color = 255 - perpWallDist * 15;
                if (side === 1) color *= 0.7; 
                ctx.fillStyle = `rgb(${color}, ${color/2}, ${color/2})`; // 紅磚牆
                ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
            }

            // 2. Sprites (敵人/Bot)
            const sprites = [];
            for (let id in players) {
                if (id === myId || players[id].hp <= 0) continue;
                sprites.push({ x: players[id].x, y: players[id].y, hp: players[id].hp, isBot: players[id].isBot });
            }
            // Bot 和 Player 用不同顏色
            sprites.sort((a, b) => ((px - b.x)**2 + (py - b.y)**2) - ((px - a.x)**2 + (py - a.y)**2));

            sprites.forEach(sprite => {
                const spriteX = (sprite.x - px) / BLOCK_SIZE;
                const spriteY = (sprite.y - py) / BLOCK_SIZE;
                const invDet = 1.0 / (planeX * dirY - dirX * planeY);
                const transformX = invDet * (dirY * spriteX - dirX * spriteY);
                const transformY = invDet * (-planeY * spriteX + planeX * spriteY);

                if (transformY > 0) {
                    const spriteScreenX = Math.floor((SCREEN_WIDTH / 2) * (1 + transformX / transformY));
                    const spriteHeight = Math.abs(Math.floor(SCREEN_HEIGHT / transformY));
                    const spriteWi
