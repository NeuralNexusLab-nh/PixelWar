<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PIXEL WAR 3D (DOOM Style)</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', monospace; }
        
        /* 讓 Canvas 呈現像素風格 (Retro Look) */
        canvas { 
            width: 100vw; 
            height: 100vh; 
            image-rendering: pixelated; 
        }

        /* UI Overlay */
        #ui { position: absolute; bottom: 10px; left: 10px; color: #0f0; font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none;}
        #crosshair { 
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; 
            transform: translate(-50%, -50%); pointer-events: none;
        }
        #crosshair::before { content: '+'; color: #0f0; font-size: 30px; }

        /* Login */
        #login { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #111; display: flex; align-items: center; justify-content: center; z-index: 10; }
        .box { text-align: center; color: white; }
        input { padding: 10px; font-size: 1.2rem; }
        button { padding: 10px 20px; font-size: 1.2rem; cursor: pointer; background: #d32f2f; color: white; border: none; }
    </style>
</head>
<body>

    <div id="login">
        <div class="box">
            <h1>PIXEL WAR 3D</h1>
            <input type="text" id="username" placeholder="Enter Name">
            <button onclick="joinGame()">ENTER BATTLE</button>
        </div>
    </div>

    <div id="crosshair"></div>
    <div id="ui">
        HP: <span id="hp">150</span>% | KILLS: <span id="kills">0</span>
    </div>
    
    <!-- 我們把內部解析度設低一點，這樣更有復古感，效能也更好 -->
    <canvas id="screen" width="320" height="200"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('screen');
        const ctx = canvas.getContext('2d');

        // Raycasting Settings
        const SCREEN_WIDTH = 320;
        const SCREEN_HEIGHT = 200;
        const FOV = Math.PI / 3; // 60 degrees
        const BLOCK_SIZE = 64;
        const MAX_DEPTH = 800; // View distance

        let map = [];
        let myId = null;
        let players = {};
        let bullets = [];
        
        // My State
        let px = 100, py = 100, pAngle = 0;
        
        // Input
        const keys = { w: false, a: false, s: false, d: false };

        function joinGame() {
            const name = document.getElementById('username').value;
            if(!name) return;
            document.getElementById('login').style.display = 'none';
            socket.emit('join', { username: name });
            
            // Mouse Lock
            canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock;
            canvas.onclick = () => canvas.requestPointerLock();
        }

        socket.on('init', (data) => {
            map = data.map;
            myId = data.id;
        });

        socket.on('state', (data) => {
            players = data.players;
            bullets = data.bullets;
            
            if (players[myId]) {
                const me = players[myId];
                px = me.x;
                py = me.y;
                pAngle = me.angle;
                document.getElementById('hp').innerText = me.hp;
                document.getElementById('kills').innerText = me.kills;
            }
        });

        // ============================
        // Raycasting Engine (The Magic)
        // ============================
        function draw3D() {
            // 1. Draw Ceiling and Floor
            ctx.fillStyle = '#333'; // Ceiling
            ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT / 2);
            ctx.fillStyle = '#222'; // Floor
            ctx.fillRect(0, SCREEN_HEIGHT / 2, SCREEN_WIDTH, SCREEN_HEIGHT / 2);

            // 2. Cast Rays for Walls
            // ZBuffer 用來處理遮擋，紀錄每個 x 軸像素的深度
            const zBuffer = new Array(SCREEN_WIDTH).fill(0);

            for (let x = 0; x < SCREEN_WIDTH; x++) {
                // Calculate ray angle
                const rayAngle = (pAngle - FOV / 2.0) + (x / SCREEN_WIDTH) * FOV;
                
                const stepSize = 5; // Ray step precision (lower = accurate but slower)
                let distanceToWall = 0;
                let hitWall = false;
                let eyeX = Math.cos(rayAngle);
                let eyeY = Math.sin(rayAngle);
                let testX = px;
                let testY = py;

                // DDA / Ray Marching
                while (!hitWall && distanceToWall < MAX_DEPTH) {
                    distanceToWall += stepSize;
                    testX = px + eyeX * distanceToWall;
                    testY = py + eyeY * distanceToWall;

                    const gridX = Math.floor(testX / BLOCK_SIZE);
                    const gridY = Math.floor(testY / BLOCK_SIZE);

                    if (gridY < 0 || gridY >= map.length || gridX < 0 || gridX >= map[0].length) {
                        hitWall = true;
                        distanceToWall = MAX_DEPTH;
                    } else if (map[gridY][gridX] === 1) {
                        hitWall = true;
                    }
                }

                // Fix fish-eye effect
                const correctedDist = distanceToWall * Math.cos(rayAngle - pAngle);
                
                // Calculate wall height
                const ceiling = (SCREEN_HEIGHT / 2.0) - SCREEN_HEIGHT / correctedDist * 40;
                const floor = SCREEN_HEIGHT - ceiling;
                const wallHeight = floor - ceiling;

                // Draw Wall Strip
                // Color based on distance (Fake lighting)
                const shade = Math.max(50, 255 - distanceToWall / 3); 
                ctx.fillStyle = `rgb(${shade}, ${shade / 2}, ${shade / 2})`; // Reddish walls
                ctx.fillRect(x, ceiling, 1, wallHeight);
                
                zBuffer[x] = distanceToWall; // Save depth
            }

            // 3. Draw Sprites (Enemies & Bullets)
            // Need to sort by distance to draw far ones first (Painter's Algorithm)
            const sprites = [];

            // Add Enemies
            for (let id in players) {
                if (id === myId) continue;
                if (players[id].hp <= 0) continue;
                sprites.push({ type: 'player', obj: players[id] });
            }
            // Add Bullets
            bullets.forEach(b => sprites.push({ type: 'bullet', obj: b }));

            // Sort logic
            sprites.forEach(s => {
                s.dist = Math.sqrt((px - s.obj.x)**2 + (py - s.obj.y)**2);
            });
            sprites.sort((a, b) => b.dist - a.dist);

            // Draw Sprites
            sprites.forEach(sprite => {
                const obj = sprite.obj;
                
                // Calculate relative position
                const dx = obj.x - px;
                const dy = obj.y - py;

                // Transform sprite with the inverse camera matrix
                // [ planeX   dirX ] -1                                       [ dirY      -dirX ]
                // [               ]       =  1/(planeX*dirY-dirX*planeY) *   [                 ]
                // [ planeY   dirY ]                                          [ -planeY  planeX ]
                
                // Simplified 2D projection math:
                // Find angle of sprite relative to player
                let spriteAngle = Math.atan2(dy, dx) - pAngle;
                while (spriteAngle < -Math.PI) spriteAngle += 2 * Math.PI;
                while (spriteAngle > Math.PI) spriteAngle -= 2 * Math.PI;

                // Only draw if in front
                if (Math.abs(spriteAngle) < FOV / 1.5) {
                    const dist = sprite.dist; // Distance
                    const screenX = (0.5 * (spriteAngle / (FOV / 2)) + 0.5) * SCREEN_WIDTH;
                    const spriteHeight = (SCREEN_HEIGHT / dist) * 60; // Scale factor
                    const spriteWidth = spriteHeight / 2; // Aspect ratio
                    const spriteTop = (SCREEN_HEIGHT - spriteHeight) / 2;

                    if (sprite.type === 'player') {
                        // Draw Enemy (Simple Box for now, or could be an image)
                        ctx.fillStyle = 'blue';
                        ctx.fillRect(screenX - spriteWidth / 2, spriteTop, spriteWidth, spriteHeight);
                        
                        // Draw Health bar
                        ctx.fillStyle = 'red';
                        ctx.fillRect(screenX - spriteWidth/2, spriteTop - 5, spriteWidth, 2);
                        ctx.fillStyle = '#0f0';
                        ctx.fillRect(screenX - spriteWidth/2, spriteTop - 5, spriteWidth * (obj.hp/150), 2);

                    } else if (sprite.type === 'bullet') {
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(screenX - 2, spriteTop + spriteHeight/2, 4, 4);
                    }
                }
            });

            // 4. Draw Weapon (AK47)
            // Simple pixel art drawn with rectangles
            const gunX = SCREEN_WIDTH / 2;
            const gunY = SCREEN_HEIGHT;
            ctx.fillStyle = '#444'; // Gun body
            ctx.fillRect(gunX - 10, gunY - 80, 20, 80);
            ctx.fillStyle = '#222'; // Barrel
            ctx.fillRect(gunX - 4, gunY - 80, 8, -20);
            
            // Muzzle flash?
            if (isMouseDown && Math.random() > 0.5) {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(gunX, gunY - 110, 10, 0, Math.PI*2);
                ctx.fill();
            }
        }

        // ============================
        // Inputs
        // ============================
        let isMouseDown = false;
        
        window.addEventListener('keydown', e => {
            if (e.key === 'w') keys.w = true;
            if (e.key === 's') keys.s = true;
            if (e.key === 'a') keys.a = true;
            if (e.key === 'd') keys.d = true;
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'w') keys.w = false;
            if (e.key === 's') keys.s = false;
            if (e.key === 'a') keys.a = false;
            if (e.key === 'd') keys.d = false;
        });
        window.addEventListener('mousedown', () => {
            isMouseDown = true;
            socket.emit('shoot');
        });
        window.addEventListener('mouseup', () => isMouseDown = false);
        
        // Mouse Look
        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                pAngle += e.movementX * 0.002;
            }
        });

        // Loop
        function loop() {
            if (myId) {
                socket.emit('input', { keys, angle: pAngle });
            }
            draw3D();
            requestAnimationFrame(loop);
        }
        loop();

    </script>
</body>
</html>
